// 【问题描述】

// 若一个线性表采用顺序表L存储，其中所有元素为整数。

// 设计一个时间空间两方面尽可能高效的算法，将所有元素划分为三部分，三部分以K1和K2为界。左边部分的元素全部小于K1，右边部分的元素全部大于或等于K2，中间部分的元素介于K1和K2之间（大于或等于K1,且小于K2）。

// 划分举例：

// 对于（6，4，20，7，9，2，10，1，3，30），已知K1=5，K2=8，一种划分结果为：（4，3，1，2，6，7，10，9，20，30）。其中，左边=（4,3,1,2）,中间=（6,7），右边=(10,9,20,30)。我们称左边部分最右元素的位置（序号）为左划分序号，右边部分最左元素的位置（序号）为右划分序号。在上例中，左划分序号为3（元素2的序号），右划分序号为6（元素10的序号）。

// 如果K1<=K2,输出一种划分；否则输出false。
// 【输入形式】

// 第一行输入两个数K1和K2。

// 第二行输入线性表的数据个数N（N<30）。

// 第三行输入线性表的整数数据。
// 【输出形式】

// 如果K1<=K2,输出左划分序号和右划分序号（用空格隔开）；否则输出false。
// 【样例输入】

// 5 8

// 10

// 6 4 20 7 9 2 10 1 3 30
// 【样例输出】

// 3 6


#include <iostream>
using namespace std;

int main() {
    int K1, K2;
    cin >> K1 >> K2;
    if (K1 > K2) {
        cout << "false" << endl;
        return 0;
    }

    int N;
    cin >> N;
    int arr[32];
    for (int i = 1; i <= N; i++) {
        cin >> arr[i];
    }

    int left=0, right=N, ptr = 1;
    while (ptr < right) {
        if (arr[ptr] < K1) {
            left++;
            swap(arr[left], arr[ptr]);
            ptr++;
        } else if (arr[ptr] >= K2) {
            right--;
            swap(arr[right], arr[ptr]);
        } else {
            ptr++;
        }
    }
    cout << left-1 << " " << right-1 << endl;
    return 0;
}